<?xml version="1.0"?>
<doc>
    <assembly>
        <name>FFMSSharp</name>
    </assembly>
    <members>
        <member name="T:FFMSSharp.SampleFormat">
            <summary>
            Identifies various audio sample formats
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_SampleFormat</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.SampleFormat.uint8_t">
            <summary>
            One 8-bit unsigned integer (uint8_t) per sample
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_FMT_U8</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.SampleFormat.int16_t">
            <summary>
            One 16-bit signed integer (int16_t) per sample
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_FMT_S16</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.SampleFormat.int32_t">
            <summary>
            One 32-bit signed integer (int32_t) per sample
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_FMT_S32</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.SampleFormat.float_t">
            <summary>
            One 32-bit (single precision) floating point value (float_t) per sample
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_FMT_FLT</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.SampleFormat.double_t">
            <summary>
            One 64-bit (double precision) floating point value (double_t) per sample
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_FMT_DBL</c>.</para>
            </remarks>
        </member>
        <member name="T:FFMSSharp.AudioChannels">
            <summary>
            Describes the audio channel layout of an audio stream
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_AudioChannel</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.AudioChannels.FrontLeft">
            <summary>
            Front Left
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_CH_FRONT_LEFT</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.AudioChannels.FrontRight">
            <summary>
            Front Right
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_CH_FRONT_RIGHT</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.AudioChannels.FrontCenter">
            <summary>
            Front Center
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_CH_FRONT_CENTER</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.AudioChannels.LowFrequency">
            <summary>
            Low Frequency Effects
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_CH_LOW_FREQUENCE</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.AudioChannels.BackLeft">
            <summary>
            Back Left
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_CH_BACK_LEFT</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.AudioChannels.BackRight">
            <summary>
            Back Right
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_CH_BACK_RIGHT</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.AudioChannels.FrontLeftOfCenter">
            <summary>
            Front Left of Center
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_CH_FRONT_LEFT_OF_CENTER</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.AudioChannels.FrontRightOfCenter">
            <summary>
            Front Right of Center
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_CH_FRONT_RIGHT_OF_CENTER</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.AudioChannels.BackCenter">
            <summary>
            Back Center
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_CH_BACK_CENTER</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.AudioChannels.SideLeft">
            <summary>
            Side Left
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_CH_SIDE_LEFT</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.AudioChannels.SideRight">
            <summary>
            Side Right
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_CH_SIDE_RIGHT</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.AudioChannels.TopCenter">
            <summary>
            Top Center
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_CH_TOP_CENTER</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.AudioChannels.TopFrontLeft">
            <summary>
            Top Front Left
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_CH_TOP_FRONT_LEFT</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.AudioChannels.TopFrontCenter">
            <summary>
            Top Front Center
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_CH_TOP_FRONT_CENTER</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.AudioChannels.TopFrontRight">
            <summary>
            Top Front Right
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_CH_TOP_FRONT_RIGHT</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.AudioChannels.TopBackLeft">
            <summary>
            Top Back Left
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_CH_TOP_BACK_LEFT</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.AudioChannels.TopBackCenter">
            <summary>
            Top Back Center
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_CH_TOP_BACK_CENTER</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.AudioChannels.TopBackRight">
            <summary>
            Top Back Right
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_CH_TOP_BACK_RIGHT</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.AudioChannels.StereoLeft">
            <summary>
            Stereo Left
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_CH_STEREO_LEFT</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.AudioChannels.StereoRight">
            <summary>
            Stereo Right
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_CH_STERO_RIGHT</c>.</para>
            </remarks>
        </member>
        <member name="T:FFMSSharp.AudioSource">
            <summary>
            Video source
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_AudioSource</c>.</para>
            <para>See <see cref="M:FFMSSharp.Index.AudioSource(System.String,System.Int32,FFMSSharp.AudioDelayMode)">Index.AudioSource</see> on how to create a <see cref="T:FFMSSharp.AudioSource">AudioSource object</see>.</para>
            <para>Note that there is no equivalent for FFMS2's <c>FFMS_GetAudioProperties</c> as it is called during construction of the <see cref="T:FFMSSharp.AudioSource">AudioSource object</see>.</para>
            </remarks>
        </member>
        <member name="P:FFMSSharp.AudioSource.SampleFormat">
            <summary>
            Audio sample format
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_AudioProperties->SampleFormat</c>.</para>
            </remarks>
        </member>
        <member name="P:FFMSSharp.AudioSource.SampleRate">
            <summary>
            Sample rate, in samples per second
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_AudioProperties->SampleRate</c>.</para>
            </remarks>
        </member>
        <member name="P:FFMSSharp.AudioSource.BitsPerSample">
            <summary>
            Bits per audio sample
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_AudioProperties->BitsPerSample</c>.</para>
            <para>Note that this signifies the number of bits actually used to code each sample, not the number of bits used to store each sample, and may hence be different from what the SampleFormat would imply.</para>
            <para>Figuring out which bytes are significant and which aren't is left as an exercise for the reader.</para>
            </remarks>
        </member>
        <member name="P:FFMSSharp.AudioSource.Channels">
            <summary>
            The number of audio channels
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_AudioProperties->Channels</c>.</para>
            </remarks>
        </member>
        <member name="P:FFMSSharp.AudioSource.ChannelLayout">
            <summary>
            The channel layout of the audio stream
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_AudioProperties->ChannelLayout</c>.</para>
            <para>Constructed by binary OR'ing the relevant integers from <see cref="P:FFMSSharp.AudioSource.ChannelLayout"/> together, which means that if the audio has the channel AudioChannel.Example, the operation (ChannelOrder &amp; AudioChannel.Example) will evaluate to true.</para>
            </remarks>
        </member>
        <member name="P:FFMSSharp.AudioSource.NumberOfSamples">
            <summary>
            The number of samples in the audio track
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_AudioProperties->NumSamples</c>.</para>
            </remarks>
        </member>
        <member name="P:FFMSSharp.AudioSource.FirstTime">
            <summary>
            The first timestamp of the stream, in seconds
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_AudioProperties->FirstTime</c>.</para>
            <para>Useful if you want to know if the stream has a delay, or for quickly determining its length in seconds.</para>
            </remarks>
            <seealso cref="P:FFMSSharp.AudioSource.LastTime"/>
        </member>
        <member name="P:FFMSSharp.AudioSource.LastTime">
            <summary>
            The last timestamp of the stream, in seconds
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_AudioProperties->LastTime</c>.</para>
            <para>Useful if you want to know if the stream has a delay, or for quickly determining its length in seconds.</para>
            </remarks>
            <seealso cref="P:FFMSSharp.AudioSource.FirstTime"/>
        </member>
        <member name="P:FFMSSharp.AudioSource.Track">
            <summary>
            Retrieves track info
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_GetTrackFromAudio</c>.</para>
            <para>It's generally safer to use this instead of <see cref="M:FFMSSharp.Index.GetTrack(System.Int32)">Index.GetTrack</see>, since unlike that function it cannot cause access violations if you specified an nonexistent track number, return a <see cref="P:FFMSSharp.AudioSource.Track">Track object</see> that doesn't actually contain any indexing information, or return an object that ceases to be valid when the index is destroyed.</para>
            <para>Note that the <see cref="P:FFMSSharp.AudioSource.Track">Track object</see> is only valid until its parent <see cref="T:FFMSSharp.AudioSource">AudioSource object</see> is destroyed.</para>
            </remarks>
        </member>
        <member name="M:FFMSSharp.AudioSource.Finalize">
            <summary>
            Audio source destructor
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_DestroyAudioSource</c>.</para>
            </remarks>
        </member>
        <member name="M:FFMSSharp.AudioSource.GetAudio(System.Int64,System.Int64)">
            <summary>
            Decode a number of audio samples
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_GetAudio</c>.</para>
            <para>The output is <paramref name="count"/> samples long, starting from <paramref name="start"/> (inclusive).</para>
            </remarks>
            <param name="start">The first sample to decode
            <para>Sample numbers start from zero and hence the last sample in the stream is number <see cref="P:FFMSSharp.AudioSource.NumberOfSamples"/> minus 1.</para>
            </param>
            <param name="count">The amount of samples to decode
            <para>Sample numbers start from zero and hence the last sample in the stream is number <see cref="P:FFMSSharp.AudioSource.NumberOfSamples"/> minus 1.</para>
            </param>
            <returns>The raw audio data</returns>
            <threadsafety instance="false"/>
            <exception cref="T:System.ArgumentOutOfRangeException">Trying to access audio samples that are out of range of the stream.</exception>
            <exception cref="T:System.NotSupportedException">Trying to start half-way into an unseekable audio stream.</exception>
        </member>
        <member name="T:FFMSSharp.ColorSpace">
            <summary>
            Identifies the color coefficients used for a YUV stream
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_ColorSpaces</c>.</para>
            <para>The numerical constants are the same as in the MPEG-2 specification.</para>
            <para>Some of these are specified or aliased in a number of places.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.ColorSpace.RGB">
            <summary>
            RGB
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_CS_RGB</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.ColorSpace.BT709">
            <summary>
            ITU-T Rec. 709
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_CS_BT709</c>.</para>
            <para>Equivalent to ITU-R BT1361, IEC 61966-2-4 xvYCC709 and SMPTE RP177 Annex B.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.ColorSpace.Unspecified">
            <summary>
            Unspecified
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_CS_UNSPECIFIED</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.ColorSpace.FCC">
            <summary>
            FCC
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_CS_FCC</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.ColorSpace.BT470BG">
            <summary>
            ITU-R BT. 470
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_CS_BT470BG</c>.</para>
            <para>Also known as ITU-T Rec. 601.</para>
            <para>Equivalent to ITU-R BT601-6 625, ITU-R BT1358 625, ITU-R BT1700 625 PAL &amp; SECAM and IEC 61966-2-4 xvYCC601.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.ColorSpace.SMPTE170M">
            <summary>
            SMPTE standard 170 M
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_CS_SMPTE170M</c>.</para>
            <para>Functionally the same as BT470BG, and is furthermore equivalent to ITU-R BT601-6 525, ITU-R BT1358 525, and ITU-R BT1700 NTSC.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.ColorSpace.SMPTE240M">
            <summary>
            SMPTE standard 240 M
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_CS_SMPTE240M</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.ColorSpace.YCoCg">
            <summary>
            YCoCg
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_CS_YCOCG</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.ColorSpace.BT2020_NCL">
            <summary>
            ITU-R BT. 2020
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_BT2020_NCL</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.ColorSpace.BT2020_CL">
            <summary>
            ITU-R BT. 2020
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_BT2020_CL</c>.</para>
            </remarks>
        </member>
        <member name="T:FFMSSharp.ColorRange">
            <summary>
            Identifies the valid range of luma values in a YUV stream
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_ColorRanges</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.ColorRange.Unspecified">
            <summary>
            Unspecified
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_CR_UNSPECIFIED</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.ColorRange.MPEG">
            <summary>
            TV range
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_CR_MPEG</c>.</para>
            <para>Valid luma values range from 16 to 235 with 8-bit color.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.ColorRange.JPEG">
            <summary>
            Full range
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_CR_JPEG</c>.</para>
            <para>All representable luma values are valid.</para>
            </remarks>
        </member>
        <member name="T:FFMSSharp.Frame">
            <summary>
            A single video frame
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_Frame</c>.</para>
            <para>See <see cref="M:FFMSSharp.VideoSource.GetFrame(System.Int32)">VideoSource.GetFrame</see> on how to create a <see cref="T:FFMSSharp.Frame">Frame object</see>.</para>
            <para>The frame is only valid until after you have called <see cref="M:FFMSSharp.VideoSource.GetFrame(System.Int32)">VideoSource.GetFrame(int)</see>/<see cref="!:VideoSource.GetFrame(double)">(double)</see>, <see cref="M:FFMSSharp.VideoSource.SetInputFormat(FFMSSharp.ColorSpace,FFMSSharp.ColorRange)">SetInputFormat(FFMSSharp.ColorSpace, FFMSSharp.ColorRange)</see>/<see cref="M:FFMSSharp.VideoSource.SetInputFormat(System.Int32,FFMSSharp.ColorSpace,FFMSSharp.ColorRange)">(int, FFMSSharp.ColorSpace, FFMSSharp.ColorRange)</see>, <see cref="M:FFMSSharp.VideoSource.ResetInputFormat">ResetInputFormat</see>, <see cref="M:FFMSSharp.VideoSource.SetOutputFormat(System.Collections.Generic.ICollection{System.Int32},System.Int32,System.Int32,FFMSSharp.Resizer)">SetOutputFormat</see>, <see cref="M:FFMSSharp.VideoSource.ResetOutputFormat">ResetOutputFormat</see>, or after the parent <see cref="T:FFMSSharp.VideoSource"/> has been destroyed.</para>
            <para>Attempting to access any data from the frame after it has been rendered invalid will result in an ObjectDisposedException.</para>
            </remarks>
        </member>
        <member name="P:FFMSSharp.Frame.Data">
            <summary>
            A list of pointers to the pixel data
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_Frame->Data</c>.</para>
            <para>Planar formats use more than one plane, for example YV12 uses one plane each for the Y, U and V data.</para>
            <para>Packed formats (such as the various RGB32 flavors) use only the first plane.</para>
            <para>If you want to determine if plane i contains data or not, check for <see cref="P:FFMSSharp.Frame.DataLength"/>[i] != 0.</para>
            </remarks>
            <exception cref="T:System.ObjectDisposedException">Trying to access data from an invalidated Frame, see <see cref="T:FFMSSharp.Frame"/>.</exception>
        </member>
        <member name="P:FFMSSharp.Frame.DataLength">
            <summary>
            A list of integers representing the length of each scan line in each of the four picture planes, in bytes
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_Frame->Linesize</c>.</para>
            <para>In alternative terminology, this is the "pitch" of the plane.</para>
            <para>Usually, the total size in bytes of picture plane i is <see cref="P:FFMSSharp.Frame.DataLength"/>[i] * <see cref="P:FFMSSharp.Frame.Resolution">Resolution.Height</see>, but do note that some pixel formats (most notably YV12) has vertical chroma subsampling, and then the U/V planes may be of a different height than the primary plane.</para>
            <para>This may be negative; if so the image is stored inverted in memory and Data actually points of the last row of the data.</para>
            <para>You usually do not need to worry about this, as it mostly works correctly by default if you're processing the image correctly.</para>
            </remarks>
            <exception cref="T:System.ObjectDisposedException">Trying to access data from an invalidated Frame, see <see cref="T:FFMSSharp.Frame"/>.</exception>
        </member>
        <member name="P:FFMSSharp.Frame.EncodedResolution">
            <summary>
            The original resolution of the frame (in pixels)
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_Frame->EncodedWidth</c> and <c>EncodedHeight</c>.</para>
            <para>As encoded in the compressed file, before any scaling was applied.</para>
            <para>Note that this must not necessarily be the same for all frames in a stream.</para>
            </remarks>
            <exception cref="T:System.ObjectDisposedException">Trying to access data from an invalidated Frame, see <see cref="T:FFMSSharp.Frame"/>.</exception>
        </member>
        <member name="P:FFMSSharp.Frame.EncodedPixelFormat">
            <summary>
            The original pixel format of the frame
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_Frame->EncodedPixelFormat</c>.</para>
            <para>As encoded in the compressed file.</para>
            </remarks>
            <exception cref="T:System.ObjectDisposedException">Trying to access data from an invalidated Frame, see <see cref="T:FFMSSharp.Frame"/>.</exception>
        </member>
        <member name="P:FFMSSharp.Frame.Resolution">
            <summary>
            The output resolution of the frame (in pixels)
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_Frame->ScaledWidth</c> and <c>ScaledHeight</c>.</para>
            <para>The resolution of what is actually stored in the <see cref="P:FFMSSharp.Frame.Data"/> field.</para>
            </remarks>
            <exception cref="T:System.ObjectDisposedException">Trying to access data from an invalidated Frame, see <see cref="T:FFMSSharp.Frame"/>.</exception>
        </member>
        <member name="P:FFMSSharp.Frame.PixelFormat">
            <summary>
            The output pixel format of the frame
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_Frame->ConvertedPixelFormat</c>.</para>
            <para>The pixel format of what is actually stored in the <see cref="P:FFMSSharp.Frame.Data"/> field.</para>
            </remarks>
            <exception cref="T:System.ObjectDisposedException">Trying to access data from an invalidated Frame, see <see cref="T:FFMSSharp.Frame"/>.</exception>
        </member>
        <member name="P:FFMSSharp.Frame.KeyFrame">
            <summary>
            Is this a keyframe?
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_Frame->KeyFrame</c>.</para>
            </remarks>
            <exception cref="T:System.ObjectDisposedException">Trying to access data from an invalidated Frame, see <see cref="T:FFMSSharp.Frame"/>.</exception>
        </member>
        <member name="P:FFMSSharp.Frame.RepeatPicture">
            <summary>
            An integer representing the RFF flag for this frame
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_Frame->RepeatPict</c>.</para>
            <para>The frame shall be displayed for 1+<see cref="P:FFMSSharp.Frame.RepeatPicture"/> time units, where the time units are expressed in the special RFF timebase available in <see cref="P:FFMSSharp.VideoSource.RFFNumerator"/> and <see cref="P:FFMSSharp.VideoSource.RFFDenominator"/>.</para>
            <para>Note that if you actually end up using this, you need to ignore the usual timestamps (calculated via the <see cref="P:FFMSSharp.Track.TimeBaseNumerator"/>/<see cref="P:FFMSSharp.Track.TimeBaseDenominator"/> and the <see cref="P:FFMSSharp.FrameInfo.PTS"/>) since they are fundamentally incompatible with RFF flags.</para>
            </remarks>
            <exception cref="T:System.ObjectDisposedException">Trying to access data from an invalidated Frame, see <see cref="T:FFMSSharp.Frame"/>.</exception>
        </member>
        <member name="P:FFMSSharp.Frame.InterlacedFrame">
            <summary>
            Is this an interlaced frame?
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_Frame->InterlacedFrame</c>.</para>
            </remarks>
            <exception cref="T:System.ObjectDisposedException">Trying to access data from an invalidated Frame, see <see cref="T:FFMSSharp.Frame"/>.</exception>
        </member>
        <member name="P:FFMSSharp.Frame.TopFieldFirst">
            <summary>
            Is the top field first?
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_Frame->TopFieldFirst</c>.</para>
            <para>Only relevant if <see cref="P:FFMSSharp.Frame.InterlacedFrame"/> is nonzero.</para>
            </remarks>
            <exception cref="T:System.ObjectDisposedException">Trying to access data from an invalidated Frame, see <see cref="T:FFMSSharp.Frame"/>.</exception>
        </member>
        <member name="P:FFMSSharp.Frame.FrameType">
            <summary>
            A single character denoting coding type (I/B/P etc) of the compressed frame
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_Frame.PictType</c>.</para>
            </remarks>
            <exception cref="T:System.ObjectDisposedException">Trying to access data from an invalidated Frame, see <see cref="T:FFMSSharp.Frame"/>.</exception>
        </member>
        <member name="P:FFMSSharp.Frame.ColorSpace">
            <summary>
            Identifies the YUV color coefficients used in the frame
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_Frame->ColorSpace</c>.</para>
            </remarks>
            <exception cref="T:System.ObjectDisposedException">Trying to access data from an invalidated Frame, see <see cref="T:FFMSSharp.Frame"/>.</exception>
            <seealso cref="P:FFMSSharp.Frame.ColorSpace"/>
        </member>
        <member name="P:FFMSSharp.Frame.ColorRange">
            <summary>
            Identifies the luma range of the frame
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_Frame->ColorRange</c>.</para>
            </remarks>
            <exception cref="T:System.ObjectDisposedException">Trying to access data from an invalidated Frame, see <see cref="T:FFMSSharp.Frame"/>.</exception>
            <seealso cref="P:FFMSSharp.Frame.ColorRange"/>
        </member>
        <member name="P:FFMSSharp.Frame.Bitmap">
            <summary>
            Turn the pixel data into a <see cref="P:FFMSSharp.Frame.Bitmap">Bitmap</see>
            </summary>
            <remarks>
            <para>This only works if you've <see cref="M:FFMSSharp.VideoSource.SetOutputFormat(System.Collections.Generic.ICollection{System.Int32},System.Int32,System.Int32,FFMSSharp.Resizer)">set the PixelFormat</see> to "bgra".</para>
            </remarks>
            <exception cref="T:System.ObjectDisposedException">Trying to access data from an invalidated Frame, see <see cref="T:FFMSSharp.Frame"/>.</exception>
        </member>
        <member name="T:FFMSSharp.FrameInfo">
            <summary>
            Information about a single video frame
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_FrameInfo</c>.</para>
            <para>See <see cref="M:FFMSSharp.Track.GetFrameInfo(System.Int32)">Track.GetFrameInfo</see> on how to create a <see cref="T:FFMSSharp.FrameInfo">FrameInfo object</see>.</para>
            </remarks>
        </member>
        <member name="P:FFMSSharp.FrameInfo.PTS">
            <summary>
            The decoding timestamp of the frame
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_FrameInfo->PTS</c>.</para>
            <para>To convert this to a timestamp in wallclock milliseconds, use the relation long timestamp = (long)((<see cref="P:FFMSSharp.FrameInfo.PTS"/> * <see cref="P:FFMSSharp.Track.TimeBaseNumerator">Track.TimeBase.Numerator</see>) / (double)<see cref="P:FFMSSharp.Track.TimeBaseDenominator">Track.TimeBase.Denumerator</see>).</para>
            </remarks>
        </member>
        <member name="P:FFMSSharp.FrameInfo.RepeatPicture">
            <summary>
            RFF flag for the frame
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_FrameInfo->RepeatPict</c>.</para>
            </remarks>
            <seealso cref="P:FFMSSharp.Frame.RepeatPicture"/>
        </member>
        <member name="P:FFMSSharp.FrameInfo.KeyFrame">
            <summary>
            Is this a keyframe?
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_FrameInfo->KeyFrame</c>.</para>
            </remarks>
        </member>
        <member name="T:FFMSSharp.SeekMode">
            <summary>
            Used to control the way seeking is handled
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_SeekMode</c>.</para>
            </remarks>
            <seealso cref="T:FFMSSharp.VideoSource" />
        </member>
        <member name="F:FFMSSharp.SeekMode.LinearNoRewind">
            <summary>
            Linear access without rewind
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_SEEK_LINEAR_NO_RW</c>.</para>
            <para>Will throw an error if each successive requested frame number isn't bigger than the last one.</para>
            <para>Only intended for opening images but might work on well with some obscure video format.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.SeekMode.Linear">
            <summary>
            Linear access
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_SEEK_LINEAR</c>.</para>
            <para>If you request frame n without having requested frames 0 to n-1 in order first, all frames from 0 to n will have to be decoded before n can be delivered.</para>
            <para>The definition of slow, but should make some formats "usable".</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.SeekMode.Normal">
            <summary>
            Safe normal
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_SEEK_NORMAL</c>.</para>
            <para>Bases seeking decisions on the keyframe positions reported by libavformat.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.SeekMode.Unsafe">
            <summary>
            Unsafe normal
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_SEEK_UNSAFE</c>.</para>
            <para>Same as <see cref="F:FFMSSharp.SeekMode.Normal" /> but no error will be thrown if the exact destination has to be guessed.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.SeekMode.Aggressive">
            <summary>
            Aggressive
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_SEEK_AGGRESSIVE</c>.</para>
            <para>Seeks in the forward direction even if no closer keyframe is known to exist.</para>
            <para>Only useful for testing and containers where libavformat doesn't report keyframes properly.</para>
            </remarks>
        </member>
        <member name="T:FFMSSharp.IndexErrorHandling">
            <summary>
            Used to control behavior when a decoding error is encountered
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_IndexErrorHandling</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.IndexErrorHandling.Abort">
            <summary>
            Abort indexing and raise an exception
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_IEH_ABORT</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.IndexErrorHandling.ClearTrack">
            <summary>
            Clear all indexing entries for the track
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_IEH_CLEAR_TRACK</c>.</para>
            <para>Returns a blank track.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.IndexErrorHandling.StopTrack">
            <summary>
            Stop indexing but keep previous indexing entries
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_IEH_STOP_TRACK</c>.</para>
            <para>Returns a track that stops where the error occurred.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.IndexErrorHandling.Ignore">
            <summary>
            Ignore the error and pretend it's raining
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_IEH_IGNORE</c>.</para>
            </remarks>
        </member>
        <member name="T:FFMSSharp.AudioDelayMode">
            <summary>
            Controls how audio with a non-zero first PTS is handled
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_AudioDelayModes</c>.</para>
            <para>In other words: what FFMS does about audio delay.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.AudioDelayMode.NoShift">
            <summary>
            No adjustment is made
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_DELAY_NO_SHIFT</c>.</para>
            <para>The first decodable audio sample becomes the first sample in the output.</para>
            <para>May lead to audio/video desync.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.AudioDelayMode.TimeZero">
            <summary>
            Samples are created (with silence) or discarded so that sample 0 in the decoded audio starts at time zero
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_DELAY_TIME_ZERO</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.AudioDelayMode.FirstVideoTrack">
            <summary>
            Samples are created (with silence) or discarded so that sample 0 in the decoded audio starts at the same time as frame 0 of the first video track
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_DELAY_FIRST_VIDEO_TRACK</c>.</para>
            <para>This is what most users want and is a sane default.</para>
            </remarks>
        </member>
        <member name="T:FFMSSharp.Index">
            <summary>
            Index of a media file
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_Index</c>.</para>
            <para>To get an Index for a media file you haven't indexed yet, use the <see cref="T:FFMSSharp.Indexer">Indexer</see> class.</para>
            </remarks>
        </member>
        <member name="P:FFMSSharp.Index.Source">
            <summary>
            Source module that was used in creating the index
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_GetSourceType</c>.</para>
            </remarks>
            <seealso cref="P:FFMSSharp.Indexer.Source"/>
        </member>
        <member name="P:FFMSSharp.Index.IndexErrorHandling">
            <summary>
            Error handling that method was used in creating of the index
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_GetErrorHandling</c>.</para>
            </remarks>
            <seealso cref="M:FFMSSharp.Indexer.Index(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.String,FFMSSharp.IndexErrorHandling)"/>
        </member>
        <member name="P:FFMSSharp.Index.NumberOfTracks">
            <summary>
            Total number of tracks in the index
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_GetNumTracks</c>.</para>
            </remarks>
        </member>
        <member name="M:FFMSSharp.Index.#ctor(System.String)">
            <summary>
            Read an index from disk
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_ReadIndex</c>.</para>
            </remarks>
            <param name="indexFile">Can be an absolute or relative path</param>
            <exception cref="T:System.IO.IOException">Trying to read an invalid index file.</exception>
            <exception cref="T:System.IO.FileNotFoundException">Trying to read an index file that does not exist.</exception>
            <exception cref="T:System.NotSupportedException">Trying to read an index file for a <see cref="P:FFMSSharp.Index.Source">Source</see> that is not available in the ffms2.dll.</exception>
        </member>
        <member name="M:FFMSSharp.Index.Dispose">
            <summary>
            Releases all resources used by the <see cref="T:FFMSSharp.Index"/>.
            </summary>
        </member>
        <member name="M:FFMSSharp.Index.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the <see cref="T:FFMSSharp.Index"/>.
            </summary>
            <param name="disposing">This doesn't do anything.</param>
        </member>
        <member name="M:FFMSSharp.Index.GetFirstTrackOfType(FFMSSharp.TrackType)">
            <summary>
            Get the track number of the first track of a specific type
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_GetFirstTrackOfType</c>.</para>
            </remarks>
            <param name="type">Track type</param>
            <returns>Track number</returns>
            <seealso cref="M:FFMSSharp.Index.GetFirstIndexedTrackOfType(FFMSSharp.TrackType)"/>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Trying to find a type of track that doesn't exist in the media file.</exception>
        </member>
        <member name="M:FFMSSharp.Index.GetFirstIndexedTrackOfType(FFMSSharp.TrackType)">
            <summary>
            Get the track number of the first indexed track of a specific type
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_GetFirstIndexedTrackOfType</c>.</para>
            <para>Does the exact same thing as <see cref="M:FFMSSharp.Index.GetFirstTrackOfType(FFMSSharp.TrackType)">GetFirstTrackOfType</see> but ignores tracks that have not been indexed.</para>
            </remarks>
            <param name="type">Track type</param>
            <returns>Track number</returns>
            <seealso cref="M:FFMSSharp.Index.GetFirstTrackOfType(FFMSSharp.TrackType)"/>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Trying to find a type of track that doesn't exist in the media file.</exception>
        </member>
        <member name="M:FFMSSharp.Index.WriteIndex(System.String)">
            <summary>
            Write the index to disk
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_WriteIndex</c>.</para>
            </remarks>
            <param name="indexFile">Can be an absolute or relative path; it will be truncated and overwritten if it already exists</param>
            <exception cref="T:System.IO.IOException">Failure to write the index</exception>
        </member>
        <member name="M:FFMSSharp.Index.BelongsToFile(System.String)">
            <summary>
            Check if the index belongs to a specific file
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_IndexBelongsToFile</c>.</para>
            <para>Makes a heuristic (but very reliable) guess about whether the index is of the <paramref name="sourceFile"/> or not.</para>
            <para>Useful to determine if the index object you just created by <see cref="M:FFMSSharp.Index.#ctor(System.String)">loading an index file from disk</see> is actually relevant to your interests, since the only two ways to pair up index files with source files are a) trust the user blindly, or b) comparing the filenames; neither is very reliable.</para>
            </remarks>
            <param name="sourceFile">File to check against</param>
            <returns>True or false depending on the result</returns>
        </member>
        <member name="M:FFMSSharp.Index.VideoSource(System.String,System.Int32,System.Int32,FFMSSharp.SeekMode)">
            <summary>
            Create a <see cref="T:FFMSSharp.VideoSource">VideoSource object</see>
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_CreateVideoSource</c>.</para>
            <para>Note that the index object is copied into the <see cref="T:FFMSSharp.VideoSource">VideoSource object</see> upon its creation, so once you've created the video source you can generally destroy the index object immediately, since all info you can retrieve from it is also retrievable from the <see cref="T:FFMSSharp.VideoSource">VideoSource object</see>.</para>
            </remarks>
            <param name="sourceFile">The media file. Can be an absolute or relative path</param>
            <param name="track">Track number of the specific video track</param>
            <param name="threads">Number of threads used for decoding
            <para>Anything less than 1 will use threads equal to the number of CPU cores.</para>
            <para>Values &gt;1 have no effect if FFmpeg was not compiled with threading support.</para></param>
            <param name="seekMode">Controls how seeking (random access) is handled and hence affects frame accuracy
            <para>Has no effect on Matroska files, where the equivalent of Normal is always used.</para>
            <para>LinearNoRw may come in handy if you want to open images.</para></param>
            <returns>The generated <see cref="T:FFMSSharp.VideoSource">VideoSource object</see></returns>
            <seealso cref="M:FFMSSharp.Index.AudioSource(System.String,System.Int32,FFMSSharp.AudioDelayMode)"/>
            <seealso cref="M:FFMSSharp.Index.GetFirstTrackOfType(FFMSSharp.TrackType)"/>
            <seealso cref="M:FFMSSharp.Index.GetFirstIndexedTrackOfType(FFMSSharp.TrackType)"/>
            <exception cref="T:System.IO.FileLoadException">Failure to open the <paramref name="sourceFile"/></exception>
            <exception cref="T:System.IO.FileNotFoundException">Trying to read a file that does not exist.</exception>
            <exception cref="T:System.ArgumentException">Trying to make a VideoSource out of an invalid track</exception>
            <exception cref="T:System.InvalidOperationException">Supplying the wrong <paramref name="sourceFile"/></exception>
        </member>
        <member name="M:FFMSSharp.Index.AudioSource(System.String,System.Int32,FFMSSharp.AudioDelayMode)">
            <summary>
            Create an <see cref="T:FFMSSharp.AudioSource">AudioSource object</see>
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_CreateAudioSource</c>.</para>
            <para>Note that the index object is copied into the <see cref="T:FFMSSharp.AudioSource">AudioSource object</see> upon its creation, so once you've created the video source you can generally destroy the index object immediately, since all info you can retrieve from it is also retrievable from the <see cref="T:FFMSSharp.AudioSource">AudioSource object</see>.</para>
            </remarks>
            <param name="sourceFile">The media file. Can be an absolute or relative path</param>
            <param name="track">Track number of the specific audio track</param>
            <param name="delayMode">Controls how audio with a non-zero first PTS is handled; in other words what FFMS does about audio delay.</param>
            <returns>The generated <see cref="T:FFMSSharp.AudioSource">AudioSource object</see></returns>
            <seealso cref="M:FFMSSharp.Index.VideoSource(System.String,System.Int32,System.Int32,FFMSSharp.SeekMode)"/>
            <seealso cref="M:FFMSSharp.Index.GetFirstTrackOfType(FFMSSharp.TrackType)"/>
            <seealso cref="M:FFMSSharp.Index.GetFirstIndexedTrackOfType(FFMSSharp.TrackType)"/>
            <exception cref="T:System.IO.FileLoadException">Failure to open the <paramref name="sourceFile"/></exception>
            <exception cref="T:System.IO.FileNotFoundException">Trying to read a file that does not exist.</exception>
            <exception cref="T:System.ArgumentException">Trying to make a AudioSource out of an invalid track</exception>
            <exception cref="T:System.InvalidOperationException">Supplying the wrong <paramref name="sourceFile"/></exception>
        </member>
        <member name="M:FFMSSharp.Index.GetTrack(System.Int32)">
            <summary>
            Create a <see cref="T:FFMSSharp.Track">Track object</see>
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_GetTrackFromIndex</c>.</para>
            <para>Use this function if you don't want to (or cannot) open the track with <see cref="M:FFMSSharp.Index.VideoSource(System.String,System.Int32,System.Int32,FFMSSharp.SeekMode)">VideoSource</see> or <see cref="M:FFMSSharp.Index.AudioSource(System.String,System.Int32,FFMSSharp.AudioDelayMode)">AudioSource</see> first.</para>
            <para>If you already have a <see cref="T:FFMSSharp.VideoSource">VideoSource object</see> or <see cref="T:FFMSSharp.AudioSource">AudioSource object</see> it's safer to use the Track property of <see cref="P:FFMSSharp.VideoSource.Track">VideoSource</see> and <see cref="P:FFMSSharp.AudioSource.Track">AudioSource</see> instead.</para>
            <para>The returned <see cref="T:FFMSSharp.Track">Track object</see> is only valid until its parent <see cref="T:FFMSSharp.Index">Index object</see> is destroyed.</para>
            <para>Requesting indexing information for a track that has not been indexed will not cause an error, it will just return an empty FFMS_Track (check for >0 frames using <see cref="P:FFMSSharp.Track.NumberOfFrames">GetNumFrames</see> to see if the returned object actually contains indexing information).</para>
            </remarks>
            <param name="track">Track number</param>
            <returns>The generated <see cref="T:FFMSSharp.Track">Track object</see></returns>
            <seealso cref="M:FFMSSharp.Index.GetFirstTrackOfType(FFMSSharp.TrackType)"/>
            <seealso cref="M:FFMSSharp.Index.GetFirstIndexedTrackOfType(FFMSSharp.TrackType)"/>
            <exception cref="T:System.ArgumentOutOfRangeException">Trying to access a Track that doesn't exist.</exception>
        </member>
        <member name="T:FFMSSharp.Source">
            <summary>
            Identifies source modules
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_Sources</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.Source.Default">
            <summary>
            Default
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_SOURCE_DEFAULT</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.Source.Lavf">
            <summary>
            libavformat (Libav/FFmpeg)
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_SOURCE_LAVF</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.Source.Matroska">
            <summary>
            Haali's BSD-licensed native Matroska parsing library
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_SOURCE_MATROSKA</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.Source.Haalimpeg">
            <summary>
            Haali's closed-source DirectShow splitter (MPEG TS/PS)
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_SOURCE_HAALIMPEG</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.Source.Haaliogg">
            <summary>
            Haali's closed-source DirectShow splitter (Ogg/OGM)
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_SOURCE_HAALIOGG</c>.</para>
            </remarks>
        </member>
        <member name="T:FFMSSharp.IndexingProgressChangeEventArgs">
            <summary>
            Event arguments for the IndexingProgressChange delegate
            </summary>
        </member>
        <member name="P:FFMSSharp.IndexingProgressChangeEventArgs.Current">
            <summary>
            Current amount of indexing done
            </summary>
        </member>
        <member name="P:FFMSSharp.IndexingProgressChangeEventArgs.Total">
            <summary>
            Total amount of indexing to do
            </summary>
        </member>
        <member name="T:FFMSSharp.Indexer">
            <summary>
            Media file indexer
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_Indexer</c>.</para>
            </remarks>
        </member>
        <member name="P:FFMSSharp.Indexer.IsIndexing">
            <summary>
            Use this to check if the Indexer is currently working
            </summary>
        </member>
        <member name="P:FFMSSharp.Indexer.CancelIndexing">
            <summary>
            Use this to cancel indexing at any point
            </summary>
        </member>
        <member name="P:FFMSSharp.Indexer.Source">
            <summary>
            Source module that was used to open the indexer
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_GetSourceTypeI</c>.</para>
            </remarks>
            <seealso cref="P:FFMSSharp.Index.Source"/>
        </member>
        <member name="P:FFMSSharp.Indexer.NumberOfTracks">
            <summary>
            The number of tracks
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_GetNumTrackI</c>.</para>
            <para>Does the same thing as <see cref="P:FFMSSharp.Index.NumberOfTracks">Index.NumberOfTracks</see> but does not require having the file indexed first.</para>
            </remarks>
            <seealso cref="P:FFMSSharp.Index.NumberOfTracks"/>
        </member>
        <member name="P:FFMSSharp.Indexer.FormatName">
            <summary>
            The name of the container format of the media file
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_GetFormatNameI</c>.</para>
            </remarks>
        </member>
        <member name="M:FFMSSharp.Indexer.#ctor(System.String,FFMSSharp.Source)">
            <summary>
            Create an indexer of a media file
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_CreateIndexer</c> or <c>FFMS_CreateIndexerWithDemuxer</c>.</para>
            <para>The chosen demuxer gets used for both indexing and decoding later on. Only force one if you know what you're doing.</para>
            <para>Picking a demuxer that doesn't work on your file will not cause automatic fallback on lavf or automatic probing; it'll just cause indexer creation to fail.</para>
            </remarks>
            <param name="sourceFile">The media file</param>
            <param name="demuxer">What demuxer to use</param>
            <exception cref="T:System.IO.FileLoadException">Failure to load the media file</exception>
        </member>
        <member name="M:FFMSSharp.Indexer.Dispose">
            <summary>
            Releases all resources used by the <see cref="T:FFMSSharp.Indexer"/>.
            </summary>
        </member>
        <member name="M:FFMSSharp.Indexer.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the <see cref="T:FFMSSharp.Indexer"/>.
            </summary>
            <param name="disposing">This doesn't do anything.</param>
        </member>
        <member name="M:FFMSSharp.Indexer.GetTrackType(System.Int32)">
            <summary>
            Get the track type of a specific track
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_GetTrackTypeI</c>.</para>
            <para>Does the same thing as <see cref="P:FFMSSharp.Track.TrackType">Track.Type</see> but does not require having the file indexed first.</para>
            <para>If you have indexed the file, use <see cref="P:FFMSSharp.Track.TrackType">Track.Type</see> instead since the <c>FFMS_Indexer</c> object is destroyed when the index is created.</para>
            </remarks>
            <param name="track">Track number</param>
            <returns>Track type</returns>
            <seealso cref="P:FFMSSharp.Track.TrackType"/>
            <exception cref="T:System.ArgumentOutOfRangeException">Trying to access a Track that doesn't exist.</exception>
            <exception cref="T:System.ObjectDisposedException">Calling this function after you have already called <see cref="M:FFMSSharp.Indexer.Index(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.String,FFMSSharp.IndexErrorHandling)"/>.</exception>
        </member>
        <member name="M:FFMSSharp.Indexer.GetCodecName(System.Int32)">
            <summary>
            Get the name of the codec used for a specific track
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_GetCodecNameI</c>.</para>
            </remarks>
            <param name="track">Track number</param>
            <returns>The human-readable name ("long name" in FFmpeg terms) of the codec</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Trying to access a Track that doesn't exist.</exception>
            <exception cref="T:System.ObjectDisposedException">Calling this function after you have already called <see cref="M:FFMSSharp.Indexer.Index(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.String,FFMSSharp.IndexErrorHandling)"/>.</exception>
        </member>
        <member name="M:FFMSSharp.Indexer.Index(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.String,FFMSSharp.IndexErrorHandling)">
            <summary>
            Index the media file
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_DoIndexing</c>.</para>
            <para>By default, you will index all <see cref="F:FFMSSharp.TrackType.Audio">Audio</see> tracks.</para>
            </remarks>
            <param name="audioIndex">A list of specific <see cref="F:FFMSSharp.TrackType.Audio">Audio</see> tracks to index</param>
            <param name="audioDump">A list of <see cref="F:FFMSSharp.TrackType.Audio">Audio</see> tracks to dump while indexing</param>
            <param name="audioDumpFileName">The filename format for audio tracks getting dumped
            <para>The following variables can be used:</para>
            <para><c>%sourcefile%</c> - same as the source file name, i.e. the file the audio is decoded from</para>
            <para><c>%trackn%</c> - the track number</para>
            <para><c>%trackzn%</c> - the track number zero padded to 2 digits</para>
            <para><c>%samplerate%</c> - the audio sample rate</para>
            <para><c>%channels%</c> - number of audio channels</para>
            <para><c>%bps%</c> - bits per sample</para>
            <para><c>%delay%</c> - delay, or more exactly the first timestamp encountered in the audio stream</para>
            <para>Example string: <c>%sourcefile%_track%trackzn%.w64</c></para></param>
            <param name="indexErrorHandling">Control behavior when a decoding error is encountered</param>
            <returns>The generated <see cref="T:FFMSSharp.Index">Index</see> object</returns>
            <event cref="E:FFMSSharp.Indexer.UpdateIndexProgress">Called to give you an update on indexing progress</event>
            <event cref="E:FFMSSharp.Indexer.OnIndexingCompleted">Called when the indexing has finished</event>
            <exception cref="T:System.NotSupportedException">Attempting to index a codec not supported by the indexer</exception>
            <exception cref="T:System.IO.InvalidDataException">Failure to index a file that should be supported</exception>
            <exception cref="T:System.OperationCanceledException">Canceling the indexing process</exception>
            <exception cref="T:System.ObjectDisposedException">Calling this function after you have already called <see cref="M:FFMSSharp.Indexer.Index(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.String,FFMSSharp.IndexErrorHandling)"/>.</exception>
        </member>
        <member name="E:FFMSSharp.Indexer.UpdateIndexProgress">
            <summary>
            Called to give you an update on indexing progress
            </summary>
            <seealso cref="T:FFMSSharp.IndexingProgressChangeEventArgs"/>
        </member>
        <member name="E:FFMSSharp.Indexer.OnIndexingCompleted">
            <summary>
            Called when the indexing has finished
            </summary>
        </member>
        <member name="T:FFMSSharp.Selection">
            <summary>
            Simple representation of a selection rectangle
            </summary>
        </member>
        <member name="P:FFMSSharp.Selection.Top">
            <summary>
            Amount of Top to crop
            </summary>
        </member>
        <member name="P:FFMSSharp.Selection.Left">
            <summary>
            Amount of Left to crop
            </summary>
        </member>
        <member name="P:FFMSSharp.Selection.Right">
            <summary>
            Amount of Right to crop
            </summary>
        </member>
        <member name="P:FFMSSharp.Selection.Bottom">
            <summary>
            Amount of Bottom to crop
            </summary>
        </member>
        <member name="T:FFMSSharp.TrackType">
            <summary>
            Used for determining the type of a given track
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_TrackType</c>.</para>
            <para>Note that there are currently no functions to handle any type of track other than <see cref="F:FFMSSharp.TrackType.Video" /> and <see cref="F:FFMSSharp.TrackType.Audio"/>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.TrackType.Unknown">
            <summary>
            Unknown
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_TYPE_UNKNOWN</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.TrackType.Video">
            <summary>
            Video
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_TYPE_VIDEO</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.TrackType.Audio">
            <summary>
            Audio
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_TYPE_AUDIO</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.TrackType.Data">
            <summary>
            Data
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_TYPE_DATA</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.TrackType.Subtitle">
            <summary>
            Subtitle
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_TYPE_SUBTITLE</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.TrackType.Attachment">
            <summary>
            Attachment
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_TYPE_ATTACHMENT</c>.</para>
            </remarks>
        </member>
        <member name="T:FFMSSharp.Track">
            <summary>
            A track of media
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_Track</c>.</para>
            <para>See <see cref="M:FFMSSharp.Index.GetTrack(System.Int32)">Index.GetTrack</see>, <see cref="P:FFMSSharp.VideoSource.Track">VideoSource.Track</see> or <see cref="P:FFMSSharp.AudioSource.Track">AudioSource.Track</see> on how to create a <see cref="T:FFMSSharp.Track">Track object</see>.</para>
            </remarks>
        </member>
        <member name="P:FFMSSharp.Track.TimeBaseNumerator">
            <summary>
            The basic time unit of the track
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_TrackTimeBase</c> and <c>FFMS_GetTimeBase</c>.</para>
            <para>Only meaningful for video tracks.</para>
            <para>Note that while this rational number may occasionally turn out to be equal to 1/framerate for some CFR video tracks, it really has no relation whatsoever with the video framerate and you should definitely not assume anything framerate-related based on it.</para>
            </remarks>
            <seealso cref="P:FFMSSharp.Track.TimeBaseDenominator"/>
        </member>
        <member name="P:FFMSSharp.Track.TimeBaseDenominator">
            <summary>
            The basic time unit of the track
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_TrackTimeBase</c> and <c>FFMS_GetTimeBase</c>.</para>
            <para>Only meaningful for video tracks.</para>
            <para>Note that while this rational number may occasionally turn out to be equal to 1/framerate for some CFR video tracks, it really has no relation whatsoever with the video framerate and you should definitely not assume anything framerate-related based on it.</para>
            </remarks>
            <seealso cref="P:FFMSSharp.Track.TimeBaseNumerator"/>
        </member>
        <member name="P:FFMSSharp.Track.TrackType">
            <summary>
            The type of the track
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_GetTrackType</c>.</para>
            </remarks>
        </member>
        <member name="P:FFMSSharp.Track.NumberOfFrames">
            <summary>
            The number of frames in the track
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_GetNumFrames</c>.</para>
            <para>For a video track this is the number of video frames, for an audio track it's the number of packets.</para>
            <para>A return value of 0 indicates the track has not been indexed.</para>
            </remarks>
        </member>
        <member name="M:FFMSSharp.Track.WriteTimecodes(System.String)">
            <summary>
            Writes timecodes for the track to disk
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_WriteTimecodes</c>.</para>
            <para>Writes Matroska v2 timecodes for the track to the given file.</para>
            <para>Only meaningful for video tracks. </para>
            </remarks>
            <param name="timecodeFile">Can be a relative or absolute path. The file will be truncated and overwritten if it already exists.</param>
            <exception cref="T:System.IO.IOException">Failure to open or write to the file</exception>
        </member>
        <member name="M:FFMSSharp.Track.GetFrameInfo(System.Int32)">
            <summary>
            Gets information about a specific frame
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_GetFrameInfo</c>.</para>
            <para>Gets information about the given frame (identified by its frame number) from the indexing information in the <see cref="T:FFMSSharp.Track">Track object</see> and returns it as a <see cref="T:FFMSSharp.FrameInfo">FrameInfo object</see>.</para>
            </remarks>
            <param name="frame">Frame number</param>
            <returns>The generated <see cref="T:FFMSSharp.FrameInfo">FrameInfo object</see>.</returns>
        </member>
        <member name="T:FFMSSharp.Resizer">
            <summary>
            Describes various image resizing algorithms
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_Resizers</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.Resizer.BilinearFast">
            <summary>
            Bilinear (Fast)
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_RESIZERS_FAST_BILINEAR</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.Resizer.Bilinear">
            <summary>
            Bilinear
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_RESIZERS_BILINEAR</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.Resizer.Bicubic">
            <summary>
            Bicubic
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_RESIZERS_BICUBIC</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.Resizer.X">
            <summary>
            X
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_RESIZERS_X</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.Resizer.Point">
            <summary>
            Point
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_RESIZERS_POINT</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.Resizer.Area">
            <summary>
            Area
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_RESIZERS_AREA</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.Resizer.BicubLin">
            <summary>
            Bicubic (Linear) <!-- I think? -->
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_RESIZERS_BICUBLIN</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.Resizer.Gauss">
            <summary>
            Gauss
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_RESIZERS_GAUSS</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.Resizer.Sinc">
            <summary>
            Sinc
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_RESIZERS_SINC</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.Resizer.Lanczos">
            <summary>
            Lanczos
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_RESIZERS_LANCZOS</c>.</para>
            </remarks>
        </member>
        <member name="F:FFMSSharp.Resizer.Spline">
            <summary>
            Spline
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_RESIZERS_SPLINE</c>.</para>
            </remarks>
        </member>
        <member name="T:FFMSSharp.VideoSource">
            <summary>
            Video source
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_VideoSource</c>.</para>
            <para>See <see cref="M:FFMSSharp.Index.VideoSource(System.String,System.Int32,System.Int32,FFMSSharp.SeekMode)">Index.VideoSource</see> on how to create a <see cref="T:FFMSSharp.VideoSource">VideoSource object</see>.</para>
            <para>Note that there is no equivalent for FFMS2's <c>FFMS_GetVideoProperties</c> as it is called during construction of the <see cref="T:FFMSSharp.VideoSource">VideoSource object</see>.</para>
            </remarks>
        </member>
        <member name="P:FFMSSharp.VideoSource.FPSNumerator">
            <summary>
            The nominal framerate of the track
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_VideoProperties->FPSNumerator</c>.</para>
            <para>For Matroska files, this number is based on the average frame duration of all frames, while for everything else it's based on the duration of the first frame.</para>
            <para>While it might seem tempting to use these values to extrapolate wallclock timestamps for each frame, you really shouldn't do that since it makes your code unable to handle variable framerate properly.</para>
            <para>The ugly reality is that these values are pretty much only useful for informational purposes; they are only somewhat reliable for antiquated containers like AVI.</para>
            <para>Normally they should never be used for practical purposes; generate individual frame timestamps from <see cref="P:FFMSSharp.FrameInfo.PTS">FrameInfo.PTS</see> instead.</para>
            </remarks>
            <seealso cref="P:FFMSSharp.VideoSource.FPSDenominator"/>
        </member>
        <member name="P:FFMSSharp.VideoSource.FPSDenominator">
            <summary>
            The nominal framerate of the track
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_VideoProperties->FPSDenominator</c>.</para>
            <para>For Matroska files, this number is based on the average frame duration of all frames, while for everything else it's based on the duration of the first frame.</para>
            <para>While it might seem tempting to use these values to extrapolate wallclock timestamps for each frame, you really shouldn't do that since it makes your code unable to handle variable framerate properly.</para>
            <para>The ugly reality is that these values are pretty much only useful for informational purposes; they are only somewhat reliable for antiquated containers like AVI.</para>
            <para>Normally they should never be used for practical purposes; generate individual frame timestamps from <see cref="P:FFMSSharp.FrameInfo.PTS">FrameInfo.PTS</see> instead.</para>
            </remarks>
            <seealso cref="P:FFMSSharp.VideoSource.FPSNumerator"/>
        </member>
        <member name="P:FFMSSharp.VideoSource.RFFNumerator">
            <summary>
            The special RFF timebase
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_VideoProperties->RFFNumerator</c>.</para>
            </remarks>
            <seealso cref="P:FFMSSharp.Frame.RepeatPicture"/>
            <seealso cref="P:FFMSSharp.VideoSource.RFFDenominator"/>
        </member>
        <member name="P:FFMSSharp.VideoSource.RFFDenominator">
            <summary>
            The special RFF timebase
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_VideoProperties->RFFDenominator</c>.</para>
            </remarks>
            <seealso cref="P:FFMSSharp.Frame.RepeatPicture"/>
            <seealso cref="P:FFMSSharp.VideoSource.RFFNumerator"/>
        </member>
        <member name="P:FFMSSharp.VideoSource.NumberOfFrames">
            <summary>
            The number of frames in the video track
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_VideoProperties->NumFrames</c>.</para>
            </remarks>
        </member>
        <member name="P:FFMSSharp.VideoSource.SampleAspectRatioNumerator">
            <summary>
            Sample aspect ratio of the video frames
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_VideoProperties->SARNum</c> and <c>SARDen</c>.</para>
            <para>Note that this is a metadata setting that you are free to ignore, but if you want the proper display aspect ratio with anamorphic material, you should honor it.</para>
            <para>On the other hand, there are situations (like when encoding) where you should probably ignore it because the user expects it to be ignored.</para>
            </remarks>
            <seealso cref="P:FFMSSharp.VideoSource.SampleAspectRatioDenominator"/>
        </member>
        <member name="P:FFMSSharp.VideoSource.SampleAspectRatioDenominator">
            <summary>
            Sample aspect ratio of the video frames
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_VideoProperties->SARNum</c> and <c>SARDen</c>.</para>
            <para>Note that this is a metadata setting that you are free to ignore, but if you want the proper display aspect ratio with anamorphic material, you should honor it.</para>
            <para>On the other hand, there are situations (like when encoding) where you should probably ignore it because the user expects it to be ignored.</para>
            </remarks>
            <seealso cref="P:FFMSSharp.VideoSource.SampleAspectRatioNumerator"/>
        </member>
        <member name="P:FFMSSharp.VideoSource.Crop">
            <summary>
            The number of pixels you should crop the frame before displaying it
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_VideoProperties->CropTop</c>, <c>CropBottom</c>, <c>CropLeft</c> and <c>CropRight</c>.</para>
            </remarks>
            <seealso cref="T:FFMSSharp.Selection"/>
        </member>
        <member name="P:FFMSSharp.VideoSource.TopFieldFirst">
            <summary>
            Is the top field first?
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_VideoProperties->TopFieldFirst</c>.</para>
            </remarks>
        </member>
        <member name="P:FFMSSharp.VideoSource.FirstTime">
            <summary>
            The first timestamp of the stream, in seconds
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_VideoProperties->FirstTime</c>.</para>
            <para>Useful if you want to know if the stream has a delay, or for quickly determining its length in seconds.</para>
            </remarks>
            <seealso cref="P:FFMSSharp.VideoSource.LastTime"/>
        </member>
        <member name="P:FFMSSharp.VideoSource.LastTime">
            <summary>
            The first timestamp of the stream, in seconds
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_VideoProperties->LastTime</c>.</para>
            <para>Useful if you want to know if the stream has a delay, or for quickly determining its length in seconds.</para>
            </remarks>
            <seealso cref="P:FFMSSharp.VideoSource.FirstTime"/>
        </member>
        <member name="P:FFMSSharp.VideoSource.Track">
            <summary>
            Retrieves track info
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_GetTrackFromVideo</c>.</para>
            <para>It's generally safer to use this instead of <see cref="M:FFMSSharp.Index.GetTrack(System.Int32)">Index.GetTrack</see>, since unlike that function it cannot cause access violations if you specified an nonexistent track number, return a <see cref="P:FFMSSharp.VideoSource.Track">Track object</see> that doesn't actually contain any indexing information, or return an object that ceases to be valid when the index is destroyed.</para>
            <para>Note that the <see cref="P:FFMSSharp.VideoSource.Track">Track object</see> is only valid until its parent <see cref="T:FFMSSharp.VideoSource">AudioSource object</see> is destroyed.</para>
            </remarks>
        </member>
        <member name="M:FFMSSharp.VideoSource.Finalize">
            <summary>
            Video source destructor
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_DestroyVideoSource</c>.</para>
            </remarks>
        </member>
        <member name="M:FFMSSharp.VideoSource.SetOutputFormat(System.Collections.Generic.ICollection{System.Int32},System.Int32,System.Int32,FFMSSharp.Resizer)">
            <summary>
            Sets the output format for video frames
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_SetOutputFormatV2</c>.</para>
            </remarks>
            <param name="targetFormats">The desired output colorspace(s)
            <para>The destination that gives the least lossy conversion from the source colorspace will automatically be selected, ON A FRAME BASIS.</para>
            <para>To get the integer constant representing a given colorspace, see <see cref="M:FFMSSharp.FFMS2.GetPixelFormat(System.String)">GetPixFmt</see>.</para>
            </param>
            <param name="width">The desired image width, in pixels
            <para>If you do not want to resize just pass the input dimensions.</para>
            </param>
            <param name="height">The desired image height, in pixels
            <para>If you do not want to resize just pass the input dimensions.</para>
            </param>
            <param name="resizer">The desired image resizing algorithm.
            <para>You must choose one even if you're not actually rescaling the image, because the video may change resolution mid-stream and then you will be using a resizer whether you want it or not (you will only know that the resolution changed after you actually decoded a frame with a new resolution), and it may also get used for rescaling subsampled chroma planes.</para>
            </param>
            <seealso cref="M:FFMSSharp.VideoSource.ResetOutputFormat"/>
            <exception cref="T:System.ArgumentOutOfRangeException">Trying to set the desired image resolution to an invalid size like 0, 0.</exception>
            <exception cref="T:System.ArgumentNullException">Trying to supply a null list of <paramref name="targetFormats"/>.</exception>
            <exception cref="T:System.ArgumentException">Trying to set an invalid output format.</exception>
        </member>
        <member name="M:FFMSSharp.VideoSource.ResetOutputFormat">
            <summary>
            Resets the video output format
            </summary>
            <param>
            <para>In FFMS2, the equivalent is <c>FFMS_ResetOutputFormatV</c>.</para>
            <para>Resets the output format so that no conversion takes place.</para>
            <para>Note that the results of this function may vary wildly, particularly if the video changes resolution mid-stream.</para>
            <para>If you call it, you'd better call <see cref="M:FFMSSharp.VideoSource.GetFrame(System.Int32)">GetFrame</see> afterwards and examine the properties to see what you actually ended up with.</para>
            </param>
        </member>
        <member name="M:FFMSSharp.VideoSource.SetInputFormat(FFMSSharp.ColorSpace,FFMSSharp.ColorRange)">
            <summary>
            Override the source format for video frames
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_SetInputFormatV</c>.</para>
            <para>Override the source colorspace passed to SWScale for conversions and resizing for all further calls to <see cref="M:FFMSSharp.VideoSource.GetFrame(System.Int32)">GetFrame</see>, until the next time you call <see cref="M:FFMSSharp.VideoSource.SetInputFormat(FFMSSharp.ColorSpace,FFMSSharp.ColorRange)">SetInputFormat</see> or <see cref="M:FFMSSharp.VideoSource.ResetInputFormat">ResetInputFormat</see>.</para>
            <para>This is intended primarily for compatibility with programs which use the wrong YUV colorspace when converting to or from RGB, but can also be useful for files which have incorrect colorspace flags.</para>
            <para>Values passed are not checked for sanity; if you wish you may tell FFMS2 to pretend that a RGB files is actually YUV using this function, but doing so is unlikely to have useful results.</para>
            <para>This function only has an effect if the output format is also set with <see cref="M:FFMSSharp.VideoSource.SetOutputFormat(System.Collections.Generic.ICollection{System.Int32},System.Int32,System.Int32,FFMSSharp.Resizer)">SetOutputFormat</see>.</para>
            </remarks>
            <param name="colorSpace">The desired input colorspace</param>
            <param name="colorRange">The desired input colorrange</param>
            <seealso cref="M:FFMSSharp.VideoSource.ResetInputFormat"/>
            <exception cref="T:System.ArgumentException">Trying to set an invalid output format.</exception>
        </member>
        <member name="M:FFMSSharp.VideoSource.SetInputFormat(System.Int32,FFMSSharp.ColorSpace,FFMSSharp.ColorRange)">
            <summary>
            Override the source format for video frames
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_SetInputFormatV</c>.</para>
            <para>Override the source colorspace passed to SWScale for conversions and resizing for all further calls to <see cref="M:FFMSSharp.VideoSource.GetFrame(System.Int32)">GetFrame</see>, until the next time you call <see cref="M:FFMSSharp.VideoSource.SetInputFormat(System.Int32,FFMSSharp.ColorSpace,FFMSSharp.ColorRange)">SetInputFormat</see> or <see cref="M:FFMSSharp.VideoSource.ResetInputFormat">ResetInputFormat</see>.</para>
            <para>This is intended primarily for compatibility with programs which use the wrong YUV colorspace when converting to or from RGB, but can also be useful for files which have incorrect colorspace flags.</para>
            <para>Values passed are not checked for sanity; if you wish you may tell FFMS2 to pretend that a RGB files is actually YUV using this function, but doing so is unlikely to have useful results.</para>
            <para>This function only has an effect if the output format is also set with <see cref="M:FFMSSharp.VideoSource.SetOutputFormat(System.Collections.Generic.ICollection{System.Int32},System.Int32,System.Int32,FFMSSharp.Resizer)">SetOutputFormat</see>.</para>
            </remarks>
            <param name="pixelFormat">The desired input pixel format</param>
            <param name="colorSpace">The desired input colorspace</param>
            <param name="colorRange">The desired input colorrange</param>
            <seealso cref="M:FFMSSharp.VideoSource.ResetInputFormat"/>
            <exception cref="T:System.ArgumentException">Trying to set an insane input format.</exception>
        </member>
        <member name="M:FFMSSharp.VideoSource.ResetInputFormat">
            <summary>
            Resets the video input format to the values specified in the source file
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_ResetInputFormatV</c>.</para>
            </remarks>
            <seealso cref="M:FFMSSharp.VideoSource.SetInputFormat(FFMSSharp.ColorSpace,FFMSSharp.ColorRange)"/>
            <seealso cref="M:FFMSSharp.VideoSource.SetInputFormat(System.Int32,FFMSSharp.ColorSpace,FFMSSharp.ColorRange)"/>
        </member>
        <member name="M:FFMSSharp.VideoSource.GetFrame(System.Int32)">
            <summary>
            Retrieves a video frame
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_GetFrame</c>.</para>
            <para>The returned frame is owned by the given <see cref="T:FFMSSharp.VideoSource">VideoSource object</see>, and remains valid until the video source is destroyed, a different frame is requested from the video source, or the video source's input or output format is changed.</para>
            </remarks>
            <param name="frame">The frame number to get
            <para>Frame numbering starts from zero, and hence the first frame is number 0 (not 1) and the last frame is number <see cref="P:FFMSSharp.VideoSource.NumberOfFrames">NumFrames</see> - 1.</para>
            </param>
            <returns>The generated <see cref="T:FFMSSharp.Frame">Frame object</see>.</returns>
            <seealso cref="!:GetFrame(double)"/>
            <exception cref="T:System.ArgumentOutOfRangeException">Trying to access a Frame that doesn't exist.</exception>
        </member>
        <member name="M:FFMSSharp.VideoSource.GetFrameByPosition(System.Int64)">
            <summary>
            Retrieves a video frame at a file position
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_GetFrameByPosition</c>.</para>
            <para>The returned frame is owned by the given <see cref="T:FFMSSharp.VideoSource">VideoSource object</see>, and remains valid until the video source is destroyed, a different frame is requested from the video source, or the video source's input or output format is changed.</para>
            <para>Does the exact same thing as <see cref="M:FFMSSharp.VideoSource.GetFrame(System.Int32)">GetFrame</see> except instead of giving it a frame number you give it a file position in bytes, and it will retrieve the frame that starts at that position.</para>
            </remarks>
            <param name="position">File position in bytes</param>
            <returns>The generated <see cref="T:FFMSSharp.Frame">Frame object</see>.</returns>
            <seealso cref="M:FFMSSharp.VideoSource.GetFrame(System.Int32)"/>
            <exception cref="T:System.ArgumentOutOfRangeException">Trying to access a Frame that doesn't exist.</exception>
        </member>
        <member name="M:FFMSSharp.VideoSource.GetFrameByTime(System.Double)">
            <summary>
            Retrieves a video frame at a timestamp
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_GetFrameByTime</c>.</para>
            <para>The returned frame is owned by the given <see cref="T:FFMSSharp.VideoSource">VideoSource object</see>, and remains valid until the video source is destroyed, a different frame is requested from the video source, or the video source's input or output format is changed.</para>
            <para>Does the exact same thing as <see cref="M:FFMSSharp.VideoSource.GetFrame(System.Int32)">GetFrame</see> except instead of giving it a frame number you give it a timestamp in seconds, and it will retrieve the frame that starts closest to that timestamp.</para>
            <para>This function exists for the people who are too lazy to build and traverse a mapping between frame numbers and timestamps themselves.</para>
            </remarks>
            <param name="time">Timestamp</param>
            <returns>The generated <see cref="T:FFMSSharp.Frame">Frame object</see>.</returns>
            <seealso cref="M:FFMSSharp.VideoSource.GetFrame(System.Int32)"/>
            <exception cref="T:System.ArgumentOutOfRangeException">Trying to access a Frame that doesn't exist.</exception>
        </member>
        <member name="T:FFMSSharp.AVLogLevel">
            <summary>
            Log level for libavformat
            </summary>
        </member>
        <member name="F:FFMSSharp.AVLogLevel.Quiet">
            <summary>
            No output
            </summary>
        </member>
        <member name="F:FFMSSharp.AVLogLevel.Panic">
            <summary>
            Something went really wrong and we will crash now
            </summary>
        </member>
        <member name="F:FFMSSharp.AVLogLevel.Fatal">
            <summary>
            Something went wrong and recovery is not possible
            </summary>
            <remarks>
            For example, no header was found for a format which depends
            on headers or an illegal combination of parameters is used.
            </remarks>
        </member>
        <member name="F:FFMSSharp.AVLogLevel.Error">
            <summary>
            Something went wrong and cannot losslessly be recovered
            </summary>
            <remarks>
            However, not all future data is affected.
            </remarks>
        </member>
        <member name="F:FFMSSharp.AVLogLevel.Warning">
            <summary>
            Something somehow does not look correct
            </summary>
            <remarks>
            This may or may not lead to problems. An example would be the use of '-vstrict -2'.
            </remarks>
        </member>
        <member name="F:FFMSSharp.AVLogLevel.Info">
            <summary>
            Show regular information
            </summary>
        </member>
        <member name="F:FFMSSharp.AVLogLevel.Verbose">
            <summary>
            Show lots of information
            </summary>
        </member>
        <member name="F:FFMSSharp.AVLogLevel.Debug">
            <summary>
            Stuff which is only useful for libav* developers
            </summary>
        </member>
        <member name="T:FFMSSharp.FFMS2">
            <summary>
            Container for generic FFMS2 functions
            </summary>
        </member>
        <member name="P:FFMSSharp.FFMS2.Initialized">
            <summary>
            Is FFMS2 initialized?
            </summary>
        </member>
        <member name="P:FFMSSharp.FFMS2.PresentSources">
            <summary>
            Source modules that the library was compiled with
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_GetPresentSources</c>.</para>
            </remarks>
        </member>
        <member name="P:FFMSSharp.FFMS2.EnabledSources">
            <summary>
            Source modules that are actually available for use
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_GetEnabledSources</c>.</para>
            </remarks>
        </member>
        <member name="P:FFMSSharp.FFMS2.Version">
            <summary>
            The FFMS_VERSION constant
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_GetVersion</c>.</para>
            <para>You may want to use <see cref="P:FFMSSharp.FFMS2.VersionString">VersionString</see> if you just want to print the version.</para>
            </remarks>
            <seealso cref="P:FFMSSharp.FFMS2.VersionString"/>
        </member>
        <member name="P:FFMSSharp.FFMS2.VersionString">
            <summary>
            A human-readable version of the FFMS_VERSION constant
            </summary>
            <returns>A pretty version string</returns>
            <seealso cref="P:FFMSSharp.FFMS2.Version"/>
        </member>
        <member name="P:FFMSSharp.FFMS2.LogLevel">
            <summary>
            FFmpeg message level
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_GetLogLevel</c> and <c>FFMS_SetLogLevel</c>.</para>
            </remarks>
        </member>
        <member name="M:FFMSSharp.FFMS2.Initialize(System.String)">
            <summary>
            Initialize the FFMS2 library
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_Init</c>.</para>
            <para>Must be called before anything else.</para>
            <para>If you can't (or don't want to) place ffms2.dll in the same directory as your .exe, you may specify a path where you store it.</para>
            </remarks>
        </member>
        <member name="M:FFMSSharp.FFMS2.IsSourcePresent(FFMSSharp.Source)">
            <summary>
            Is the source compiled in the library?
            </summary>
            <param name="option">The source in question</param>
            <returns>The result</returns>
        </member>
        <member name="M:FFMSSharp.FFMS2.IsSourceEnabled(FFMSSharp.Source)">
            <summary>
            Is the source currently enabled?
            </summary>
            <param name="option">The source in question</param>
            <returns>The result</returns>
        </member>
        <member name="M:FFMSSharp.FFMS2.GetPixelFormat(System.String)">
            <summary>
            Gets a colorspace identifier from a colorspace name
            </summary>
            <remarks>
            <para>In FFMS2, the equivalent is <c>FFMS_GetPixFmt</c>.</para>
            <para>Translates a given pixel format name to an integer constant representing it, suitable for passing to <see cref="M:FFMSSharp.VideoSource.SetOutputFormat(System.Collections.Generic.ICollection{System.Int32},System.Int32,System.Int32,FFMSSharp.Resizer)">VideoSource.SetOutputFormat</see>.</para>
            <para>This function exists so that you don't have to include a FFmpeg header file in every single program you ever write.</para>
            <para>For a list of colorspaces and their names, see libavutil/pixfmt.h.</para>
            <para>To get the name of a colorspace, strip the leading PIX_FMT_ and convert the remainder to lowercase.</para>
            <para>For example, the name of PIX_FMT_YUV420P is yuv420p.</para>
            <para>It is strongly recommended to use this function instead of including pixfmt.h directly, since this function guarantees that you will always get the constant definitions from the version of FFmpeg that FFMS2 was linked against.</para>
            </remarks>
            <param name="name">ASCII string identifying the pixel format.</param>
            <returns>Integer identifying the pixel format.</returns>
            <exception cref="T:System.ArgumentException">Invalid pixel format identifier.</exception>
        </member>
    </members>
</doc>
